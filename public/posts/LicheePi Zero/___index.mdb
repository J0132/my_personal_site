
---
title: "Lichee pi Zero, гайд по созданию образа ОС"
date: 2026-02-26

---

Статья является пересборкой моей же статьи от 22.02.2021 года: 
"Битва с одноплатным чудовищем. LicheePi Zero. Страх, боль и страдания." 
Писалась она для моей группы vk.com, и я ей доволен по этому редактировать буду мало что. Сейчас делаю перепост дабы познакомится.
В остальном этот гайд может помочь вам собрать образ для sd карты чтобы lichee pi запустилась. И через еще три поста, статья улетит в архив.

![LicheePi Zero.](https://sun9-28.userapi.com/s/v1/ig2/pdRCF4DcQL530xG5-DWYCqseUb01PXEtVJqfMTOTbnek5PjdVbKWFqFspvwlTMr0HcwZTpWLGgnMiKarPAj-IWQO.jpg?quality=96&as=32x24,48x36,72x54,108x81,160x120,240x180,360x270,480x360,540x405,640x480,720x540,1080x810&from=bu&cs=1080x0)
LicheePi Zero.
#### Начало?:
И так, в дебрях алиэкспресса была найдена эта привлекательная по цене и габаритам плата микрокомпьютера. Как раз начиналось мое увлечение одноплатными компьютерами. И я не смог не побаловать себя сием приобретением. Однако как плата прибыла все попытки запустить ее банальным способом как raspberry pi не увенчались успехом. После консультации с хорошим другом, я осознал что флешку надо создавать в линуксе на худой конец в WSL. Я под это дело из закрамов собрал компьютер на линуксе, вы же можете попробовать сделать флешку в WSL, однако я не гарантирую успехов в этом. И так вот как я запустил licheepi будет рассказано дальше.

**Набор инструментов.**

Обновите репозитории и установите набор инструментов следующим образом:

`$ sudo apt update`

`$ sudo apt install gcc-arm-linux-gnueabihf`

Убедитесь что ваша система обновлена. Требуется как минимум версия  
6.0 U-Boot.

**U-boot.**

Первый шаг - скомпилировать наш загрузчик.  
Клонируйте репозиторий U-Boot с помощью:

`$ git clone https://github.com/u-boot/u-boot.git`

`$ cd u-boot`

Вам могут понадобиться библиотеки swing и python-dev. Установите их, прежде чем продолжить процесс компиляции U-Boot.

`$ sudo apt install swig python-dev`

Чтобы скомпилировать U-Boot для нашей конкретной установки, мы будем использовать тот, `configs/LicheePi_Zero_defconfig`который предоставляется как часть основного репозитория U-Boot, который мы только что клонировали.

`$ make CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig`

Если это сработает, скомпилируйте загрузчик:

`$ make CROSS_COMPILE=arm-linux-gnueabihf-`

На данном этапе могут возникнуть проблемы с инструментами если выдает ошибку «что-то not found» лечится установкой этого «что-то».  

Если все идет хорошо, система должна сгенерировать файл с именем 
`u-boot-sunxi-with-spl.bin`. Это двоичный файл загрузчика, и мы скопируем на нашу SD-карту, как только у нас будут готовы все остальные компоненты.

**Ядро системы.**

Далее мы скомпилируем ядро. Для этого нам понадобится форк Lichee репозитория Linux. Они создали конфигурацию ядра, которая хорошо работает на их плате. Самостоятельное определение правильной конфигурации было бы долгим и трудным процессом, поэтому мы будем использовать эту конфигурацию для установки нашего ядра. Делаем не глубокий клон:

`$ git clone --single-branch --branch="zero-5.2.y" --depth=1 
https://github.com/Lichee-Pi/linux.git`

Переходим в каталог linux:

`$ cd linux`

Выполните конфигурацию, выполнив следующую команду. Это проанализирует конфигурацию ядра и сгенерирует файл .config, который Make будет использовать для компиляции нашего ядра.

`$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-licheepi_zero_defconfig`

Если это удастся, то вы готовы скомпилировать ядро. Отметьте, сколько потоков / ядер вашей рабочей станции вы хотите назначить для задания, и используйте опцию `-j`, чтобы разделить рабочую нагрузку между ними. Например, в моей системе 4 потоков, поэтому я буду использовать `-j4`.

`$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf -j4 all`

Это также скомпилирует дерево устройств. Вкратце аппаратная настройка устройства описана в `arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dts`файле. Процесс компиляции (с `make all`) скомпилирует файл `.dts`в скомпилированный «двоичный» `.dtb`файл, который загрузчик или система может прочитать. Мы скопируем этот `.dtb` файл на нашу загрузочную SD-карту вместе с файлом zImage.

Нам также потребуется скомпилировать и установить модули ядра. Соберите модули и убедитесь, что INSTALL_MOD_PATH установлен в какой-то пустой каталог, к которому вы сможете получить доступ позже. Мы извлечем дерево модулей из этого каталога.

`$ sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 modules`

`$ sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 modules_install INSTALL_MOD_PATH=/path/to/some/directory`

### Сценарий загрузки.

Чтобы автоматизировать процесс загрузки U-Boot, мы создадим небольшой файл, который будет автоматически запускаться скриптом. Он содержит несколько команд U-Boot, которые будут запускаться при инициализации U-Boot. Создайте файл с именем boot.cmd, содержащий следующие команды U-Boot:

`$ sudo nano U-Boot`

Добавьте в файл следующий текст:

`setenv bootargs console=ttyS0,115200 root=/dev/mmcblk0p2 rootwait panic=10`

`load mmc 0:1 0x43000000 ${fdtfile}`

`load mmc 0:1 0x42000000 zImage`

`bootz 0x42000000 - 0x43000000`

После того, как вы создали `boot.cmd`файл с этими командами, мы отформатируем этот файл в `.scr`двоичный файл сценария, который может использовать U-Boot. Выполните команду:

`$ mkimage -C none -A arm -T script -d boot.cmd boot.scr`

Файл `boot.scr` , что мы создали, скопируем на SD - карту. `boot.cmd`использовать не будем.

### Rootfs.

«Rootfs» - это файловая система, которая фактически используется операционной системой. Он содержит почти все, что операционной системе необходимо, чтобы предоставить пользователю (или в данном случае root) все удобства, которые можно ожидать при использовании системы Linux. Он будет содержать двоичные файлы общих приложений, таких как текстовые редакторы, системные утилиты, а также системные файлы и программы.

Есть несколько способов создать rootfs. Я добился успеха только с двумя методами, но это в основном из-за моей неопытности, а не из-за реальных технических ограничений. Лучший метод, который я нашел, - это использовать утилиту Buildroot для создания rootfs на основе BusyBox, который содержит урезанные версии общих утилит Linux. Это лучше всего подходит для систем с крайне ограниченными ресурсами; он не даст вам более продвинутых функций, таких как компилятор C, управление пакетами или другие функции. Тем не менее, процесс сборки безболезненный, автономный и относительно защищенный от идиотов, что хорошо поддается учебному пособию для начинающих.

Загрузите [последнюю стабильную версию Buildroot](https://buildroot.org/download.html), распакуйте и установите приложение.

Мы выберем несколько вариантов для нашей конфигурации Buildroot. Запустите конфигуратор на основе меню.

`$ make menuconfig`

Обратите внимание что может не запускаться если окно консоли не растянуто на весь экран.

Выберите следующие параметры. Если вам бросается в глаза что-то еще, и вы думаете, что это может помочь вашей системе, смело выбирайте и это.

![Настройки rootfs](https://sun9-41.userapi.com/s/v1/ig2/lLI8f9znrcxz6Ja0YxJDdaJb-81Ojtkz9TBP7oirADXQ4X9WXgTbcasuN3Elk-80pAKBrvFHNlqPGdeme6hEk-Pf.jpg?quality=96&as=32x18,48x27,72x41,108x62,160x91,240x137,360x206,480x274,540x309,640x366,720x411,735x420&from=bu&cs=735x0)
Настройки rootfs

Особо следует отметить опции для включенных утилит Busybox. Busybox предоставляет набор часто используемых утилит, но некоторые из них предоставляются дополнительно.

Некоторые из них, которые я хотел бы порекомендовать:

![утилиты](https://sun9-37.userapi.com/s/v1/ig2/-P3OnOhLLy-CF2C05hgpNIR6RmV1mizH16GslZHYoShl1XJD6Hft14FK6gRw3eSsNjv-e0yw0o0CfxtvjIzSBRUD.jpg?quality=96&as=32x24,48x36,72x53,108x80,160x119,240x178,360x267,480x356,540x401,640x475,720x535,726x539&from=bu&cs=726x0)
утилиты

После того, как вы настроили систему Buildroot с помощью BusyBox, создайте файловую систему:

`$ make`

Да, это действительно так просто. Это займет некоторое время (особенно на более медленных системах), поэтому сделайте чашку чая, расслабьтесь и ~~покурите~~. Несколько интересных заметок пока вы ждете:

- Buildroot будет использовать собственную внутреннюю, недавно загруженную цепочку инструментов компилятора (если она выбрана).
- Buildroot разрешит большую часть внутренних зависимостей во время компиляции, если не все.
- Это помогает сборкам быть более надежными, менее подверженными странным несоответствиям пакетов и просто в целом более удобными и защищенными от неопытного пользователя.

После завершения длительного процесса сборки `rootfs.tar`в вашей папке`output` будет файл . Это то, что мы разархивируем на нашу SD-карту.

## SD Card.

Для начала отчистим и разметим нашу карточку. Для этого будем использовать утилиту GParted.

`$ sudo apt-get install gparted`

Размечаем первую половину карты в fat16 при этом требуется совсем небольшой объём памяти. Я разметил на 128 МиБ.

![Первый раздел.](https://sun9-45.userapi.com/s/v1/ig2/BD018TRs7ebb9U_-6z_dB0VX2Je5S4J_HLVWmDAAflNqHClEjiXZynb5uhhj-j-sP3uPEsJR3jf1eIhf9BO2G3er.jpg?quality=96&as=32x23,48x34,72x51,108x77,160x114,240x171,360x257,480x342,540x385,579x413&from=bu&cs=579x0)
Первый раздел.

Второй раздел делаем весь в ext4. Теперь наша карта должна выглядить так:

![Общий вид разметки карты.](https://sun9-61.userapi.com/s/v1/ig2/eLDVGL6V8T09ttBYgeRllsvQE1OpcvLGbIVaihBcjZyel9R8LGIGtg9YLPj_v1ZRuSdL04W5xZIZeESzGUf9G73m.jpg?quality=96&as=32x23,48x35,72x53,108x79,160x117,240x176,360x264,480x352,540x396,587x431&from=bu&cs=587x0)
Общий вид разметки карты.

Посмотрим свою карту в консоли командой: `sudo fdisk -l` . Я вижу свою SD-карту как `/dev/sdс`. Вы можете увидите свою карту как `/dev/sdX`, где X - это некоторая буква, в зависимости от вашей конфигурации и подключения других SD/USB-устройств.

**Убедитесь, что вы выбрали правильное устройство. Если вы случайно выберете неправильное устройство, вы можете безвозвратно уничтожить данные на другом устройстве и безвозвратно потерять свою информацию.**

После того, как вы идентифицировали свое устройство для удобства, экспортируйте имя как переменную оболочки:

`$ export card=/dev/sdX`

Затем мы записываем бинарный файл загрузчика на устройство. Найдите `u-boot-sunxi-with-spl.bin` который мы создали ранее. У меня лежал в папке u-boot. И данной командой запишите на карту его:

`$ sudo dd if=u-boot/u-boot-sunxi-with-spl.bin of=${card} bs=1024 seek=8`

Записываем так потому что загрузчик должен начинаться с первых 8 КБ в области памяти нашей карточки.

Теперь, когда у нас созданы разделы и файловые системы, пора скопировать наши файлы в эти файловые системы. Сначала мы монтируем загрузочный раздел SD-карты в нашу хост-систему.

`$ sudo mount ${card}1 /mnt/`

Затем мы копируем наши файлы в загрузочный раздел.

`$ sudo cp /path/to/your/linux/repo/arch/arm/boot/zImage /mnt/`

`$ sudo cp /path/to/your/script/boot.scr /mnt/`

`$ sudo cp /path/to/your/linux/repo/arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dtb /mnt/`

Затем синхронизируйте все изменения и отключите SD-карту.

`$ sync`

`$ sudo umount /dev/`

Затем мы можем смонтировать основной раздел ext4 и скопировать созданные нами rootfs.

`$ sudo mount ${card}2 /mnt/`

Файлы rootfs, которые мы создали с помощью Buildroot, должны находиться в `/path/to/your/buildroot/output/images`папке. Cкопируйте на SD-карту с помощью:

`$ tar -C /mnt/ -xf images/rootfs.tar`

Осмотрите SD-карту и убедитесь, что корневая файловая система была правильно извлечена. Запуск `ls /mnt/`должен вернуть что-то, что в целом выглядит примерно так:

![Файлы на втором разделе карты.](https://sun9-48.userapi.com/s/v1/ig2/uf1twAKgIdCCGP5kjHmdql94IRVzcdkiIlIKbD5ffpXySOCy3AZRtxog2rnjnt33MJj-g65kz6eYePIswoPDfPVJ.jpg?quality=96&as=32x5,48x7,72x11,108x17,160x25,240x37,360x55,480x74,540x83,640x98,720x110,756x116&from=bu&cs=756x0)

Файлы на втором разделе карты.

Если нет, удалите все с SD-карты ( `sudo rm -rf /mnt/*`) и повторите попытку.

Затем мы скопируем модули ядра, которые мы скомпилировали ранее. Вызовите каталог, в который вы их скомпилировали, и выполните следующие команды:

`$ sudo mkdir -p /mnt/lib/modules`

`$ sudo rm -rf /mnt/lib/modules/`

`$ sudo cp -r <YOUR_MODULE_DIRECTORY>/output/lib /mnt/`

Процесс копирования rootfs завершен! Если все работает правильно, теперь у вас должна быть полностью работающая SD-карта для вашего устройства.

По завершении синхронизируйте и отключите SD-карту.

`$ sync`

`$ sudo umount /dev/`

## FTDI / UART.

Все готово теперь мы можем запустить наш микрокомпьютер. Для этого вставляем карточку в слот. И подключаем USB/TTL конвертер к плате.

![Распиновка.](https://sun9-67.userapi.com/s/v1/ig2/Uw5c7HNxd0d8vwYy2VowwnnIP_4cuDf9awb5w-sw5pvVeuSWhJ7xFDVfoNwz3VHQ44kXLQJJ1WU9bCoM-QdbFi4H.jpg?quality=96&as=32x51,48x77,72x115,108x173,160x256,240x383,360x575,480x767,540x863,640x1022,720x1150,1080x1725,1280x2045,1352x2160&from=bu&cs=1080x0)
Распиновка.

Нам нужен UART0. 
**Подключаем TX конвертера к RX платы и соответственно RX конвертера к TX платы.**

Теперь вставляем конвертер в ПК, я использую для этого виндовую машину и самый дешёвый USB/TTL конвертер. В диспетчере устройств смотрим виртуальный ком порт который эмулирует драйвер конвертера:

![Компорт.](https://sun9-76.userapi.com/s/v1/ig2/WT5hH-nrQhhelgNLFhlrOnnjs3LAT5aYYbGAfqwlXIIAT0_Svm8ftYZ3D4jZpuDszcXUrt6oyPEQ9WUKWPBsCZbO.jpg?quality=96&as=32x23,48x35,72x52,108x79,160x117,240x175,360x263,480x350,540x394,640x467,720x525,809x590&from=bu&cs=809x0)
Компорт.

Также проверьте в доп настройках драйвера чтобы скорость соответствовала 115200.

Теперь заходим в Putty и настраиваем как на скрине:

![Настройки Putty.](https://sun9-53.userapi.com/s/v1/ig2/Tkshq955FrX-Bv-aLHA_mciqPFe8ykKpQXgorCqRpOIzI8gs9ixat36ErzIkMV2t_VDPP0jUegrh8aUWecDCXEY-.jpg?quality=96&as=32x32,48x48,72x72,108x108,160x160,240x239,360x359,378x377&from=bu&cs=378x0)
Настройки Putty.

Теперь запускаем putty и подаем +5 вольт и землю с TTL конвертера.  
видим результат:

![Финал наших трудов.](https://sun9-64.userapi.com/s/v1/ig2/wnMSvhRdwuBUdKHKX2LrKDkzrgBz1qMganNh1f8FSM--nPDOZMhHDdE6eoC0FVdVd9GodxCPIcwKjzhCyyUGph7O.jpg?quality=96&as=32x21,48x31,72x46,108x70,160x103,240x155,360x233,480x310,540x349,545x352&from=bu&cs=545x0)
Финал наших трудов.

Все, можете развлекаться с платой как вашей душе угодно. 

Использованные материалы, а также благодарность:

https://zee2.github.io/2020/01/18/licheepi-zero/

https://licheepizero.us/