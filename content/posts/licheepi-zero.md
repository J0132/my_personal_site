
---
title: "Lichee pi Zero, гайд по созданию образа ОС"
date: 2026-02-26

---

Статья является пересборкой моей же статьи от 22.02.2021 года: 
"Битва с одноплатным чудовищем. LicheePi Zero. Страх, боль и страдания." 
Писалась она для моей группы vk.com, и я ей доволен по этому редактировать буду мало что. Сейчас делаю перепост дабы познакомится с вами.
В остальном этот гайд может помочь вам собрать образ для sd карты чтобы lichee pi запустилась. 
И через еще три поста, эта статья улетит в архив.


![licheepi](/images/licheepi.jpg)
#### Начало:
И так, в дебрях алиэкспресса была найдена эта привлекательная по цене и габаритам плата микрокомпьютера. Как раз начиналось мое увлечение одноплатными компьютерами. И я не смог не побаловать себя сием приобретением. Однако как плата прибыла все попытки запустить ее банальным способом как raspberry pi не увенчались успехом. После консультации с хорошим другом, я осознал что флешку надо создавать в линуксе на худой конец в WSL. Я под это дело из закрамов собрал компьютер на линуксе, вы же можете попробовать сделать флешку в WSL, однако я не гарантирую успехов в этом. И так вот как я запустил licheepi будет рассказано дальше.

**Набор инструментов.**

**Знак $ не копируем!!!!!**

Обновите репозитории и установите набор инструментов следующим образом:

`$ sudo apt update`

`$ sudo apt install gcc-arm-linux-gnueabihf`

Убедитесь что ваша система обновлена. Требуется как минимум версия  
6.0 U-Boot.

**U-boot.**

Первый шаг - скомпилировать наш загрузчик.  
Клонируйте репозиторий U-Boot с помощью:

`$ git clone https://github.com/u-boot/u-boot.git`

`$ cd u-boot`

Вам могут понадобиться библиотеки swing и python-dev. Установите их, прежде чем продолжить процесс компиляции U-Boot.

`$ sudo apt install swig python-dev`

Чтобы скомпилировать U-Boot для нашей конкретной установки, мы будем использовать тот, `configs/LicheePi_Zero_defconfig`который предоставляется как часть основного репозитория U-Boot, который мы только что клонировали.

`$ make CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig`

Если это сработает, скомпилируйте загрузчик:

`$ make CROSS_COMPILE=arm-linux-gnueabihf-`

На данном этапе могут возникнуть проблемы с инструментами если выдает ошибку «что-то not found» лечится установкой этого «что-то».  

Если все идет хорошо, система должна сгенерировать файл с именем 
`u-boot-sunxi-with-spl.bin`. Это двоичный файл загрузчика, и мы скопируем на нашу SD-карту, как только у нас будут готовы все остальные компоненты.

**Ядро системы.**

Далее мы скомпилируем ядро. Для этого нам понадобится форк Lichee репозитория Linux. Они создали конфигурацию ядра, которая хорошо работает на их плате. Самостоятельное определение правильной конфигурации было бы долгим и трудным процессом, поэтому мы будем использовать эту конфигурацию для установки нашего ядра. Делаем не глубокий клон:

`$ git clone --single-branch --branch="zero-5.2.y" --depth=1 
https://github.com/Lichee-Pi/linux.git`

Переходим в каталог linux:

`$ cd linux`

Выполните конфигурацию, выполнив следующую команду. Это проанализирует конфигурацию ядра и сгенерирует файл .config, который Make будет использовать для компиляции нашего ядра.

`$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-licheepi_zero_defconfig`

Если это удастся, то вы готовы скомпилировать ядро. Отметьте, сколько потоков / ядер вашей рабочей станции вы хотите назначить для задания, и используйте опцию `-j`, чтобы разделить рабочую нагрузку между ними. Например, в моей системе 4 потоков, поэтому я буду использовать `-j4`.

`$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf -j4 all`

Это также скомпилирует дерево устройств. Вкратце аппаратная настройка устройства описана в `arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dts`файле. Процесс компиляции (с `make all`) скомпилирует файл `.dts`в скомпилированный «двоичный» `.dtb`файл, который загрузчик или система может прочитать. Мы скопируем этот `.dtb` файл на нашу загрузочную SD-карту вместе с файлом zImage.

Нам также потребуется скомпилировать и установить модули ядра. Соберите модули и убедитесь, что INSTALL_MOD_PATH установлен в какой-то пустой каталог, к которому вы сможете получить доступ позже. Мы извлечем дерево модулей из этого каталога.

`$ sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 modules`

`$ sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 modules_install INSTALL_MOD_PATH=/path/to/some/directory`

### Сценарий загрузки.

Чтобы автоматизировать процесс загрузки U-Boot, мы создадим небольшой файл, который будет автоматически запускаться скриптом. Он содержит несколько команд U-Boot, которые будут запускаться при инициализации U-Boot. Создайте файл с именем boot.cmd, содержащий следующие команды U-Boot:

`$ sudo nano U-Boot`

Добавьте в файл следующий текст:

`setenv bootargs console=ttyS0,115200 root=/dev/mmcblk0p2 rootwait panic=10`

`load mmc 0:1 0x43000000 ${fdtfile}`

`load mmc 0:1 0x42000000 zImage`

`bootz 0x42000000 - 0x43000000`

После того, как вы создали `boot.cmd`файл с этими командами, мы отформатируем этот файл в `.scr`двоичный файл сценария, который может использовать U-Boot. Выполните команду:

`$ mkimage -C none -A arm -T script -d boot.cmd boot.scr`

Файл `boot.scr` , что мы создали, скопируем на SD - карту. `boot.cmd`использовать не будем.

### Rootfs.

«Rootfs» - это файловая система, которая фактически используется операционной системой. Он содержит почти все, что операционной системе необходимо, чтобы предоставить пользователю (или в данном случае root) все удобства, которые можно ожидать при использовании системы Linux. Он будет содержать двоичные файлы общих приложений, таких как текстовые редакторы, системные утилиты, а также системные файлы и программы.

Есть несколько способов создать rootfs. Я добился успеха только с двумя методами, но это в основном из-за моей неопытности, а не из-за реальных технических ограничений. Лучший метод, который я нашел, - это использовать утилиту Buildroot для создания rootfs на основе BusyBox, который содержит урезанные версии общих утилит Linux. Это лучше всего подходит для систем с крайне ограниченными ресурсами; он не даст вам более продвинутых функций, таких как компилятор C, управление пакетами или другие функции. Тем не менее, процесс сборки безболезненный, автономный и относительно защищенный от идиотов, что хорошо поддается учебному пособию для начинающих.

Загрузите [последнюю стабильную версию Buildroot](https://buildroot.org/download.html), распакуйте и установите приложение.

Мы выберем несколько вариантов для нашей конфигурации Buildroot. Запустите конфигуратор на основе меню.

`$ make menuconfig`

Обратите внимание что может не запускаться если окно консоли не растянуто на весь экран.

Выберите следующие параметры. Если вам бросается в глаза что-то еще, и вы думаете, что это может помочь вашей системе, смело выбирайте и это.

![rootfs](/images/rootfs.jpg)
Настройки rootfs

Особо следует отметить опции для включенных утилит Busybox. Busybox предоставляет набор часто используемых утилит, но некоторые из них предоставляются дополнительно.

Некоторые из них, которые я хотел бы порекомендовать:

![utlites](/images/utilites.jpg)
утилиты

После того, как вы настроили систему Buildroot с помощью BusyBox, создайте файловую систему:

`$ make`

Да, это действительно так просто. Это займет некоторое время (особенно на более медленных системах), поэтому сделайте чашку чая, расслабьтесь и ~~покурите~~. Несколько интересных заметок пока вы ждете:

- Buildroot будет использовать собственную внутреннюю, недавно загруженную цепочку инструментов компилятора (если она выбрана).
- Buildroot разрешит большую часть внутренних зависимостей во время компиляции, если не все.
- Это помогает сборкам быть более надежными, менее подверженными странным несоответствиям пакетов и просто в целом более удобными и защищенными от неопытного пользователя.

После завершения длительного процесса сборки `rootfs.tar`в вашей папке`output` будет файл . Это то, что мы разархивируем на нашу SD-карту.

## SD Card.

Для начала отчистим и разметим нашу карточку. Для этого будем использовать утилиту GParted.

`$ sudo apt-get install gparted`

Размечаем первую половину карты в fat16 при этом требуется совсем небольшой объём памяти. Я разметил на 128 МиБ.

![Первый раздел.](/images/gprted.jpg)
Первый раздел.

Второй раздел делаем весь в ext4. Теперь наша карта должна выглядить так:

![Общий вид разметки карты.](/images/gparted2.jpg)
Общий вид разметки карты.

Посмотрим свою карту в консоли командой: `sudo fdisk -l` . Я вижу свою SD-карту как `/dev/sdс`. Вы можете увидите свою карту как `/dev/sdX`, где X - это некоторая буква, в зависимости от вашей конфигурации и подключения других SD/USB-устройств.

**Убедитесь, что вы выбрали правильное устройство. Если вы случайно выберете неправильное устройство, вы можете безвозвратно уничтожить данные на другом устройстве и безвозвратно потерять свою информацию.**

После того, как вы идентифицировали свое устройство для удобства, экспортируйте имя как переменную оболочки:

`$ export card=/dev/sdX`

Затем мы записываем бинарный файл загрузчика на устройство. Найдите `u-boot-sunxi-with-spl.bin` который мы создали ранее. У меня лежал в папке u-boot. И данной командой запишите на карту его:

`$ sudo dd if=u-boot/u-boot-sunxi-with-spl.bin of=${card} bs=1024 seek=8`

Записываем так потому что загрузчик должен начинаться с первых 8 КБ в области памяти нашей карточки.

Теперь, когда у нас созданы разделы и файловые системы, пора скопировать наши файлы в эти файловые системы. Сначала мы монтируем загрузочный раздел SD-карты в нашу хост-систему.

`$ sudo mount ${card}1 /mnt/`

Затем мы копируем наши файлы в загрузочный раздел.

`$ sudo cp /path/to/your/linux/repo/arch/arm/boot/zImage /mnt/`

`$ sudo cp /path/to/your/script/boot.scr /mnt/`

`$ sudo cp /path/to/your/linux/repo/arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dtb /mnt/`

Затем синхронизируйте все изменения и отключите SD-карту.

`$ sync`

`$ sudo umount /dev/`

Затем мы можем смонтировать основной раздел ext4 и скопировать созданные нами rootfs.

`$ sudo mount ${card}2 /mnt/`

Файлы rootfs, которые мы создали с помощью Buildroot, должны находиться в `/path/to/your/buildroot/output/images`папке. Cкопируйте на SD-карту с помощью:

`$ tar -C /mnt/ -xf images/rootfs.tar`

Осмотрите SD-карту и убедитесь, что корневая файловая система была правильно извлечена. Запуск `ls /mnt/`должен вернуть что-то, что в целом выглядит примерно так:

![Файлы на втором разделе карты.](/images/filesystem.jpg)

Файлы на втором разделе карты.

Если нет, удалите все с SD-карты ( `sudo rm -rf /mnt/*`) и повторите попытку.

Затем мы скопируем модули ядра, которые мы скомпилировали ранее. Вызовите каталог, в который вы их скомпилировали, и выполните следующие команды:

`$ sudo mkdir -p /mnt/lib/modules`

`$ sudo rm -rf /mnt/lib/modules/`

`$ sudo cp -r <YOUR_MODULE_DIRECTORY>/output/lib /mnt/`

Процесс копирования rootfs завершен! Если все работает правильно, теперь у вас должна быть полностью работающая SD-карта для вашего устройства.

По завершении синхронизируйте и отключите SD-карту.

`$ sync`

`$ sudo umount /dev/`

## FTDI / UART.

Все готово теперь мы можем запустить наш микрокомпьютер. Для этого вставляем карточку в слот. И подключаем USB/TTL конвертер к плате.

![Распиновка.](/images/pinout.jpg)
Распиновка.

Нам нужен UART0. 
**Подключаем TX конвертера к RX платы и соответственно RX конвертера к TX платы.**

Теперь вставляем конвертер в ПК, я использую для этого виндовую машину и самый дешёвый USB/TTL конвертер. В диспетчере устройств смотрим виртуальный ком порт который эмулирует драйвер конвертера:

![Компорт.](/images/comport.jpg)
Компорт.

Также проверьте в доп настройках драйвера чтобы скорость соответствовала 115200.

Теперь заходим в Putty и настраиваем как на скрине:

![Настройки Putty.](/images/putti.jpg)
Настройки Putty.

Теперь запускаем putty и подаем +5 вольт и землю с TTL конвертера.  
видим результат:

![Финал наших трудов.](/images/term.jpg)
Финал наших трудов.

Все, можете развлекаться с платой как вашей душе угодно. 

Использованные материалы, а также благодарность:

https://zee2.github.io/2020/01/18/licheepi-zero/

https://licheepizero.us/
